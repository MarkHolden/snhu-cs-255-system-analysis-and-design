# CS-255 System Analysis and Design

## Briefly summarize the DriverPass project.
The DriverPass project is to design and develop a system that allows student users to purchase and schedule driver training, track progress, allow employees to manage students and product offerings, and make it easy for administrators to blame specific employees for minor, correctable mistakes and lock their accounts when they are fired.   

## Who was the client?
DriverPass is a driver training company with the mission to assist drivers in passing both the written and practical application portions of the driving test. The owner and information technology person also seem to have an unhealthy obsession with placing blame on specific users and making sure the firing process is streamlined.

## What type of system did they want you to design?
The system that the client requested is a simplified customer relationship manager (CRM) that incorporates a learning management system (LMS). The aspects of the system that I focused on primarily was the CRM aspect because the requirements of the LMS portion of the system were so poorly documented that any design based on them would have been easy to shred apart during grading.

## What did you do particularly well?
Something that I do particularly well in general is question requirements. Several of the requirements given, both by the notional client and coworkers were dumb. For example, one of the coworkers stated that the simple crud operations for creating and updating reservation packages was too difficult to do and was out of scope. As soon as I read that I knew that the notional coworker was being portrayed as an idiot for the purposes of the assignment and everything that they said could be disregarded. Unfortunately, I took being oppositional to everything that coworker said to an extreme, and when the client requested something that was quite clearly ridiculous and unnecessary for this use case - the ability to update the system in an offline state and have it synchronize when it comes back online - I developed a way to make that happen in spite of the fact that it adds unnecessary complexity to the system for a dubious benefit.

## If you could choose one part of your work on these documents to revise, what would you pick?
I would revise the work that I did related to the appearance of the user interface (UI). The UI mock-up provided by the client was unintuitive, ugly, and contained components that were absent from the rest of the requirements entirely. 

## How would you improve it?
The fact that I worked on each of these documents in a vacuum without any input from the client or other software engineers is alarming. The way that I would improve that outside of the context of a classroom is to have open lines of communication with the client. The assumptions that I made to move the assignment forward would need to be confirmed by the client and other stakeholders. I would also submit as many drafts to the client as were required to receive their approval on the business requirements before starting the software specification.

Specific improvements to the UI mock-up would be that I would confirm the unstated additional requirements that were only in the mock-up but discussed nowhere else, then provide all the requirements that the client requested to real designer(s) to come up with wire-frames to be approved by the client. If the client had feedback on the wire-frames, then as many iterations as required to get that right would be taken. Once the wire-frames were satisfactory, I would have the designer(s) develop full blown UI mock-ups to suggest to the client. The designers should create more than one different suggestion to present to the client. The client could then pick one of the suggestions, incorporate elements from other suggestions, request changes to a suggestion, or reject all suggestions and ask for a redesign. The design process would be iterated on to come up with the system that will provide the most benefit to the client. In the event that there is obvious development that will need to be done regardless of the UI design, that can be done in parallel to the design iterations to speed up time to market.

## How did you interpret the user’s needs and implement them into your system design?
I interpreted the end user's needs by placing myself in the perspective of a student user of the system, and thinking about what I would want to do with the system were I to be in that position. One example of a requirement that I changed unilaterally (of course in real life this would be approved by the client) was to allow student users to create their own account without having to call the DriverPass office. If a company was selling something that I had to call to create an account for, I personally would find another provider that allows self-service in this regard.

## Why is it so important to consider the user’s needs when designing?
There were some explicit needs that the customer communicated, and there were some implicit needs that were not communicated. As a professional software engineer, it is my responsibility to fill the knowledge gaps that the client has in order to provide them the information they need to make the best decision for their software. Given that in a classroom environment there is no two-way communication with the client, the only communication was a single interview transcript where the individuals present in the interview did not take the time to fully explore the requirements that the client tried to communicate, and told the client that trivial things could not be done while accepting immensely complex and high risk requests without question. Without asking the necessary questions, many assumptions have to be made in order to fulfill the requirements. Outside of a classroom setting, this is not a problem, if there is any question about the client's requirements, you can just ask.

Interpreting the user's needs was done by taking the stated requirements of the client and ignoring everything that the characters in the scenario that were supposed to be my coworkers. With the requirements given by the client, I colored in some of the requirements from my experience implementing similar software in the past, both working as a project manager for four years and a software engineer for the past five years. For all the remaining gaps in the client requirements I imagined what I would want if I were the end user and I was using the system to do business with the client. Normally, that would be a draft that would be reviewed by the client for edits, but that step is omitted in the classroom environment.

The reason why it is important to take the end user into account when designing a system is that they are the ones actually using it on a day-to-day basis. If there are aspects of the system that are confusing or hard to use, they are the ones that suffer the most, and typically they are in a position where they have very little input on the design of the system. Having great user interface/user experience (UI/UX) designers is a huge benefit in this regard, but there is no substitute for getting end users involved early by releasing alpha and beta versions of the software internally, and getting feedback from non-technical users.

## How do you approach designing software?
I believe that a hybrid agile/waterfall approach or a full blown agile approach (if the limitations of agile discussed below are acceptable to the client) are the proper approaches to designing software or designing anything of consequence for that matter. There are unknown unknowns in every system design, and if they are not accounted for they can cause real problems.

A short list of limitations of agile for the purposes of helping a client decide if it is the right approach for them is

* Total project dollar value is based on time spent and can only be estimated and not promised.
* Project schedule is an estimate and will fluctuate based on client feedback.

Another approach to software design was detailed in the eponymous 2004 book by Eric Evans, Domain-Driven Design. Curiously absent from an undergraduate level course on system design, this approach focuses on the domain language of the problem space and that the purpose of the system should be obvious from looking at the code. It is sometimes called screaming architecture, because the architecture should be so obvious about the reason for it's existence that it can be said to "scream" this information.

## What techniques or strategies would you use in the future to analyze and design a system?
The techniques or strategies that I will use in the future to analyze and design a system will be the principles of domain driven design. The company that I work for places emphasis on this strategy and I was disappointed to not learn anything about it in a System Analysis and Design class and was further disappointed that the textbook has no mention of it whatsoever. To develop my skill in this area, I will continue to read Vaughn Vernon's book Domain-Driven Design Distilled, and the aforementioned book by Eric Evans.